# edpm/engine/generators/cmake_generator.py

import os
import json

class CmakeGenerator:
    def __init__(self, plan, lock):
        self.plan = plan
        self.lock = lock

    ############################
    # 1) Toolchain
    ############################
    def build_toolchain_text(self) -> str:
        """
        Return purely EDPM-generated lines for a .cmake toolchain file
        (no merging).
        """
        lines = []
        lines.append("# Automatically generated by EDPM\n")
        lines.append("# Do not edit by hand!\n\n")

        # Maybe gather environment or special CMakeSet actions
        global_env = self.plan.get_global_env_actions()
        for act in global_env:
            if hasattr(act, 'gen_cmake_line'):
                lines.append(act.gen_cmake_line() + "\n")

        # Then for each installed dependency:
        for dep_name in sorted(self.lock.get_all_dependencies()):
            dep_data = self.lock.get_dependency(dep_name)
            ipath = dep_data.get("install_path", "")
            if not ipath or not os.path.isdir(ipath):
                continue

            dep_obj = self.plan.find_dependency(dep_name)
            if not dep_obj:
                continue

            placeholders = {"install_dir": ipath}
            env_actions = dep_obj.env_block().parse(placeholders)
            for act in env_actions:
                if hasattr(act, 'gen_cmake_line'):
                    lines.append(act.gen_cmake_line() + "\n")

        return "".join(lines)

    def save_toolchain_with_infile(self, in_file: str, out_file: str):
        """
        If in_file is None => just write build_toolchain_text() to out_file
        Otherwise read in_file, look for '# {{{EDPM-CONTENT}}}' insertion
        """
        edpm_text = self.build_toolchain_text()
        if in_file is None:
            self._write_text(out_file, edpm_text)
            return

        with open(in_file, "r", encoding="utf-8") as f:
            original_lines = f.readlines()

        marker = "# {{{EDPM-CONTENT}}}"
        inserted = False
        new_lines = []
        for line in original_lines:
            if marker in line:
                new_lines.append(edpm_text)
                inserted = True
            else:
                new_lines.append(line)

        if not inserted:
            new_lines.append("\n# EDPM content appended:\n")
            new_lines.append(edpm_text)

        merged_text = "".join(new_lines)
        self._write_text(out_file, merged_text)

    ############################
    # 2) CMakePresets
    ############################
    def build_presets_json(self) -> str:
        """
        Build purely EDPM-based CMakePresets (in JSON).
        If you want to do logic like 'cacheVariables' => gather them here.
        Return as a JSON string.
        """
        # Minimal example:
        preset = {
            "version": 3,
            "cmakeMinimumRequired": {"major":3, "minor":21},
            "configurePresets": [
                {
                    "name": "edpm",
                    "displayName": "EDPM-based config",
                    "generator": "Unix Makefiles",
                    "cacheVariables": {}
                }
            ]
        }

        # Potentially fill 'cacheVariables' from environment or recipes
        # e.g. gather some CmakeSet actions
        # for each installed ...
        # pseudo example:
        # preset["configurePresets"][0]["cacheVariables"]["ROOT_DIR"] = "/path/to/root"

        return json.dumps(preset, indent=2)

    def save_presets_with_infile(self, in_file: str, out_file: str):
        """
        If in_file is None => write build_presets_json() to out_file
        If in_file is not None => parse the JSON, then merge EDPM-based stuff
        """
        edpm_json_str = self.build_presets_json()
        edpm_data = json.loads(edpm_json_str)

        if in_file is None:
            # no merging
            self._write_text(out_file, edpm_json_str)
            return

        # read & parse existing
        with open(in_file, "r", encoding="utf-8") as f:
            try:
                original_data = json.load(f)
            except json.JSONDecodeError:
                # fallback if invalid
                original_data = {}

        # We do a naive "merge" approach. For example, we might:
        # - ensure original_data["version"] = edpm_data["version"] if not present
        # - ensure original_data["configurePresets"] exists
        # - For each 'configurePresets', we either merge or replace.
        #   In practice you can get fancy or keep it simple.

        # Minimal example of merging EDPM's "configurePresets" into "original_data".
        # We'll look for a preset named "edpm" in original, or append if missing.
        edpm_preset = None
        if "configurePresets" in edpm_data:
            # we assume there's only 1 in this example
            edpm_preset = edpm_data["configurePresets"][0]
        else:
            edpm_preset = None

        if "configurePresets" not in original_data:
            original_data["configurePresets"] = []

        # see if there's an existing "edpm" preset
        found_index = None
        for i, existing_preset in enumerate(original_data["configurePresets"]):
            if existing_preset.get("name") == "edpm":
                found_index = i
                break

        if edpm_preset:
            if found_index is not None:
                # We overwrite or merge
                original_data["configurePresets"][found_index] = edpm_preset
            else:
                # append
                original_data["configurePresets"].append(edpm_preset)

        # version
        original_data["version"] = edpm_data.get("version", 3)
        original_data["cmakeMinimumRequired"] = edpm_data.get("cmakeMinimumRequired", {"major":3,"minor":21})

        # now write back
        final_json = json.dumps(original_data, indent=2)
        self._write_text(out_file, final_json)

    def _write_text(self, filename, text):
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        with open(filename, "w", encoding="utf-8") as f:
            f.write(text)
